{
  "config_name": "Generate CTL (Computational Tree Logic) constraints from business process requirements",
  "input_variables": {
    "REQUIREMENT": "Default requirement: User submits order, system processes it.",
    "SYMBOL": "{\n  \"actor\": [\n    {\n      \"actor_name\": \"User\",\n      \"symbol\": \"A\"\n    },\n    {\n      \"actor_name\": \"System\",\n      \"symbol\": \"B\"\n    }\n  ],\n  \"tasks\": [\n    {\n      \"actor_symbol\": \"A\",\n      \"task_description\": \"User submits order\",\n      \"task_symbol\": \"T1\"\n    },\n    {\n      \"actor_symbol\": \"B\",\n      \"task_description\": \"System processes the order\",\n      \"task_symbol\": \"T2\"\n    },\n    {\n      \"actor_symbol\": \"A\",\n      \"task_description\": \"initial of User\",\n      \"task_symbol\": \"S1\"\n    },\n    {\n      \"actor_symbol\": \"A\",\n      \"task_description\": \"end of User\",\n      \"task_symbol\": \"E1\"\n    },\n    {\n      \"actor_symbol\": \"B\",\n      \"task_description\": \"initial of System\",\n      \"task_symbol\": \"S2\"\n    },\n    {\n      \"actor_symbol\": \"B\",\n      \"task_description\": \"end of System\",\n      \"task_symbol\": \"E2\"\n    }\n  ]\n}",
    "FLOW": "{\n  \"control_flow\": [\n    {\n      \"actor\": \"A\",\n      \"from\": \"S1\",\n      \"to\": \"T1\"\n    },\n    {\n      \"actor\": \"A\",\n      \"from\": \"T1\",\n      \"to\": \"T2-r1\"\n    },\n    {\n      \"actor\": \"B\",\n      \"from\": \"S2\",\n      \"to\": \"T2\"\n    },\n    {\n      \"actor\": \"B\",\n      \"from\": \"T2\",\n      \"to\": \"E2\"\n    },\n    {\n      \"actor\": \"A\",\n      \"from\": \"T2-r1\",\n      \"to\": \"E1-r1\"\n    },\n    {\n      \"actor\": \"A\",\n      \"from\": \"E1-r1\",\n      \"to\": \"E1\"\n    },\n    {\n      \"actor\": \"B\",\n      \"from\": \"E2-r1\",\n      \"to\": \"E2\"\n    }\n  ],\n  \"message_flow\": [\n    {\n      \"from_actor\": \"A\",\n      \"to_actor\": \"B\",\n      \"from\": \"T1\",\n      \"to\": \"T2-r1\"\n    },\n    {\n      \"from_actor\": \"A\",\n      \"to_actor\": \"B\",\n      \"from\": \"T2\",\n      \"to\": \"E2-r1\"\n    },\n    {\n      \"from_actor\": \"B\",\n      \"to_actor\": \"A\",\n      \"from\": \"T2\",\n      \"to\": \"E1-r1\"\n    }\n  ]\n}"
  },
  "full_prompt": "Task: Generate CTL (Computational Tree Logic) constraints from business process requirements\n\nInput variables:\nREQUIREMENT: Default requirement: User submits order, system processes it.\nSYMBOL: {\n  \"actor\": [\n    {\n      \"actor_name\": \"User\",\n      \"symbol\": \"A\"\n    },\n    {\n      \"actor_name\": \"System\",\n      \"symbol\": \"B\"\n    }\n  ],\n  \"tasks\": [\n    {\n      \"actor_symbol\": \"A\",\n      \"task_description\": \"User submits order\",\n      \"task_symbol\": \"T1\"\n    },\n    {\n      \"actor_symbol\": \"B\",\n      \"task_description\": \"System processes the order\",\n      \"task_symbol\": \"T2\"\n    },\n    {\n      \"actor_symbol\": \"A\",\n      \"task_description\": \"initial of User\",\n      \"task_symbol\": \"S1\"\n    },\n    {\n      \"actor_symbol\": \"A\",\n      \"task_description\": \"end of User\",\n      \"task_symbol\": \"E1\"\n    },\n    {\n      \"actor_symbol\": \"B\",\n      \"task_description\": \"initial of System\",\n      \"task_symbol\": \"S2\"\n    },\n    {\n      \"actor_symbol\": \"B\",\n      \"task_description\": \"end of System\",\n      \"task_symbol\": \"E2\"\n    }\n  ]\n}\nFLOW: {\n  \"control_flow\": [\n    {\n      \"actor\": \"A\",\n      \"from\": \"S1\",\n      \"to\": \"T1\"\n    },\n    {\n      \"actor\": \"A\",\n      \"from\": \"T1\",\n      \"to\": \"T2-r1\"\n    },\n    {\n      \"actor\": \"B\",\n      \"from\": \"S2\",\n      \"to\": \"T2\"\n    },\n    {\n      \"actor\": \"B\",\n      \"from\": \"T2\",\n      \"to\": \"E2\"\n    },\n    {\n      \"actor\": \"A\",\n      \"from\": \"T2-r1\",\n      \"to\": \"E1-r1\"\n    },\n    {\n      \"actor\": \"A\",\n      \"from\": \"E1-r1\",\n      \"to\": \"E1\"\n    },\n    {\n      \"actor\": \"B\",\n      \"from\": \"E2-r1\",\n      \"to\": \"E2\"\n    }\n  ],\n  \"message_flow\": [\n    {\n      \"from_actor\": \"A\",\n      \"to_actor\": \"B\",\n      \"from\": \"T1\",\n      \"to\": \"T2-r1\"\n    },\n    {\n      \"from_actor\": \"A\",\n      \"to_actor\": \"B\",\n      \"from\": \"T2\",\n      \"to\": \"E2-r1\"\n    },\n    {\n      \"from_actor\": \"B\",\n      \"to_actor\": \"A\",\n      \"from\": \"T2\",\n      \"to\": \"E1-r1\"\n    }\n  ]\n}\n\nGiven the following business process information:\n- REQUIREMENT: REQUIREMENT\n- SYMBOL: SYMBOL\n- Control flow and message dependencies: FLOW\n\nGenerate a list of CTL (Computational Tree Logic) constraints that formally encode the requirement. Ensure:\n\n1. Symbol Compliance: All variables/atomic propositions MUST use symbols from the provided SYMBOL mapping.\n2. Requirement Alignment: Constraints must directly reflect the semantics of the requirement.\n3. Formal Syntax: Use standard CTL operators (AG, AF, EF, EG, AU, EU, etc.) and logical connectives (and, or, not, ->).\n4. Standard Format: Output must follow the exact JSON structure specified.\n\nStep-by-Step Process:\n1. Requirement Analysis: Break down the requirement into temporal/logical patterns.\n2. Symbol Mapping: Identify relevant symbols from SYMBOL for each activity in the requirement.\n3. Constraint Generation: Propose CTL formulas adhering to the requirement and symbols.\n4. Validation: Ensure no unmapped variables are used.\n\nOutput Format Requirements:\n- Each constraint must have: constraint_id, ctl_formula, description, requirement_reference, constraint_type\n- ctl_formula must be a valid CTL formula using only symbols from SYMBOL\n- constraint_type must be one of: safety_properties, liveness_properties, response_properties, precedence_properties\n- Use standard CTL syntax with proper parentheses and operator precedence\n\nOutput format requirements:\n- ctl_constraints:\n  - type: array\n  - items: {'type': 'object', 'properties': {'constraint_id': {'type': 'string', 'description': \"Unique identifier for the constraint (e.g., 'C001', 'C002')\"}, 'ctl_formula': {'type': 'string', 'description': 'Valid CTL formula using symbols from SYMBOL mapping', 'examples': ['AG(T1 -> AF(T2))', 'EF(T1 and T2)', 'AG(T1 -> (not T2 U T3))']}, 'description': {'type': 'string', 'description': 'Human-readable description of what the constraint verifies'}, 'requirement_reference': {'type': 'string', 'description': 'Reference to the specific part of the requirement this constraint addresses'}, 'constraint_type': {'type': 'string', 'enum': ['safety_properties', 'liveness_properties', 'response_properties', 'precedence_properties'], 'description': 'Type of temporal property being verified'}}, 'required': ['constraint_id', 'ctl_formula', 'description', 'requirement_reference', 'constraint_type']}\n- constraint_types:\n  - safety_properties: Properties that assert something bad never happens (AG not bad_state)\n  - liveness_properties: Properties that assert something good eventually happens (AF good_state)\n  - response_properties: Properties that assert if something happens, something else must follow (AG(trigger -> AF(response)))\n  - precedence_properties: Properties that assert ordering constraints (AG(response -> A(not response U trigger)))\n- ctl_operators:\n  - AG: Always Globally - property holds in all states of all paths\n  - AF: Always Finally - property eventually holds in all paths\n  - EF: Exists Finally - property eventually holds in some path\n  - EG: Exists Globally - property holds in all states of some path\n  - AU: Always Until - first property holds until second property becomes true in all paths\n  - EU: Exists Until - first property holds until second property becomes true in some path\n  - AX: Always Next - property holds in all next states\n  - EX: Exists Next - property holds in some next state\n- symbol_compliance: All atomic propositions in CTL formulas must correspond to task symbols (e.g., T1, T2) or actor symbols (e.g., A, B) from the provided SYMBOL mapping. Do not use unmapped variables.\n- example_output:\n  - ctl_constraints: [{'constraint_id': 'C001', 'ctl_formula': 'AG(T1 -> AF(T2))', 'description': 'Whenever task T1 is executed, task T2 must eventually be executed', 'requirement_reference': 'Sequential execution requirement', 'constraint_type': 'response_properties'}, {'constraint_id': 'C002', 'ctl_formula': 'AG(not(T1 and T2))', 'description': 'Tasks T1 and T2 cannot be executed simultaneously', 'requirement_reference': 'Mutual exclusion requirement', 'constraint_type': 'safety_properties'}]\n",
  "llm_response": "```json\n{\n  \"ctl_constraints\": [\n    {\n      \"constraint_id\": \"C001\",\n      \"ctl_formula\": \"AG(T1 -> AF(T2))\",\n      \"description\": \"Whenever the User submits an order (T1), the System must eventually process the order (T2).\",\n      \"requirement_reference\": \"Sequential execution requirement\",\n      \"constraint_type\": \"response_properties\"\n    },\n    {\n      \"constraint_id\": \"C002\",\n      \"ctl_formula\": \"AG(T2 -> AF(E2))\",\n      \"description\": \"Whenever the System processes an order (T2), it must eventually reach its end state (E2).\",\n      \"requirement_reference\": \"System completion requirement\",\n      \"constraint_type\": \"liveness_properties\"\n    },\n    {\n      \"constraint_id\": \"C003\",\n      \"ctl_formula\": \"AG(E1 -> AF(T1))\",\n      \"description\": \"Whenever the User reaches their end state (E1), they must eventually submit a new order (T1).\",\n      \"requirement_reference\": \"User engagement requirement\",\n      \"constraint_type\": \"liveness_properties\"\n    },\n    {\n      \"constraint_id\": \"C004\",\n      \"ctl_formula\": \"AG(E2 -> AF(E1))\",\n      \"description\": \"Whenever the System reaches its end state (E2), the User must eventually reach their end state (E1).\",\n      \"requirement_reference\": \"User-System interaction completion requirement\",\n      \"constraint_type\": \"response_properties\"\n    },\n    {\n      \"constraint_id\": \"C005\",\n      \"ctl_formula\": \"AG(T1 -> (not T2 U E1))\",\n      \"description\": \"If the User submits an order (T1), the System must complete processing that order (T2) before the User can end (E1).\",\n      \"requirement_reference\": \"Processing precedence requirement\",\n      \"constraint_type\": \"precedence_properties\"\n    }\n  ]\n}\n```",
  "extracted_output": {
    "ctl_constraints": [
      {
        "constraint_id": "C001",
        "ctl_formula": "AG(T1 -> AF(T2))",
        "description": "Whenever the User submits an order (T1), the System must eventually process the order (T2).",
        "requirement_reference": "Sequential execution requirement",
        "constraint_type": "response_properties"
      },
      {
        "constraint_id": "C002",
        "ctl_formula": "AG(T2 -> AF(E2))",
        "description": "Whenever the System processes an order (T2), it must eventually reach its end state (E2).",
        "requirement_reference": "System completion requirement",
        "constraint_type": "liveness_properties"
      },
      {
        "constraint_id": "C003",
        "ctl_formula": "AG(E1 -> AF(T1))",
        "description": "Whenever the User reaches their end state (E1), they must eventually submit a new order (T1).",
        "requirement_reference": "User engagement requirement",
        "constraint_type": "liveness_properties"
      },
      {
        "constraint_id": "C004",
        "ctl_formula": "AG(E2 -> AF(E1))",
        "description": "Whenever the System reaches its end state (E2), the User must eventually reach their end state (E1).",
        "requirement_reference": "User-System interaction completion requirement",
        "constraint_type": "response_properties"
      },
      {
        "constraint_id": "C005",
        "ctl_formula": "AG(T1 -> (not T2 U E1))",
        "description": "If the User submits an order (T1), the System must complete processing that order (T2) before the User can end (E1).",
        "requirement_reference": "Processing precedence requirement",
        "constraint_type": "precedence_properties"
      }
    ]
  }
}